\documentclass[12pt]{article}

\usepackage{graphicx} % Required for inserting images
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[polish]{babel} % Używamy języka polskiego
\usepackage{amsmath}       % Do symboli matematycznych
\usepackage{graphicx}
\usepackage{booktabs}      % Do ładnych tabel (\toprule, \midrule, \bottomrule)
\usepackage{pdflscape}
\usepackage{multicol}

\usepackage{geometry}      % Lepsze marginesy
\geometry{a4paper, margin=1.5cm}

\title{Obliczenia Naukowe lista 5 - Sprawozdanie}
\author{Joel Kojma}
\date{\today}

\begin{document}

\maketitle

\section*{Pomysł na implementację eliminacji Gaussa dla macierzy rzadkich}
\begin{enumerate}
    \item Będziemy przechowywać macierz w postaci listy wektorów. Każdy wektor będzie odpowiadał jednemu wierszowi macierzy i będzie zawierał wartości od pierwszego niezerowego elementu w wierszu do ostatniego niezerowego elementu w wierszu. W ten sposób przechowujemy tylko niezerowe elementy macierzy. Dodatkowo będziemy używać tablicy offsetów (przesunięć), która mówi ile początkowych zer jest w każdym wierszu. Również będziemy mieli wektor długości wierszy - przechowuje długość tablicy.
\end{enumerate}

\section*{Złożoność pamięciowa}
\begin{enumerate}
    \item Tablice \texttt{row\_offsets} i \texttt{row\_lengths} służące do przeliczania indeksów mają rozmiar $n$.
    \item W każdym wierszu pamiętamy elementy macierzy $A_k$, których jest dokładnie $l$, z macierzy $C_k$ pamiętamy aż do elementu niezerowego na przekątnej, więc średnio jest to $l/2$ elementów na wiersz. W macierzy $B_k$ pamiętamy dokładnie średnio na wiersz $\left(\dfrac{2l-1}{l^2}\right) \simeq \frac{2}{l}$ elementów. \\ Zatem złożoność pamięciowa naszej implementacji eliminacji Gaussa wynosi: $O(n \cdot l)$, więc jeśli $l$ jest stałe, to złożoność pamięciowa jest liniowa względem rozmiaru macierzy $n$.
\end{enumerate}

\section*{Złożoność obliczeniowa}
\begin{enumerate}
    \item Eliminacja Gaussa: Doprowadzenie do postaci macierzy trójkątnej górnej:
    \begin{itemize}
        \item Przechodzimy po wszystkich kolumnach macierzy ($n$ kolumn)
        \item Dla każdej kolumny przechodzimy przez wszystkie wiersze poniżej przekątnej (z własności macierzy jest ich nie więcej niż $l$). W każdym wierszu wykonujemy eliminację gaussa. Mnożymy nie więcej niż $2l$ razy, ponieważ nie musimy mnożyć przez elementy równe zero ponieważ nic nie zmieniają.
        \item Zatem złożoność obliczeniowa eliminacji Gaussa wynosi $O(n \cdot l \cdot 2l) = O(n \cdot l^2)$, więc jeśli $l$ jest stałe, to złożoność obliczeniowa jest liniowa względem rozmiaru macierzy $n$.
        \item Dla wariantu z częściowym wyborem elementu głównego, dodatkowo w każdej kolumnie musimy znaleźć maksymalny element w kolumnie spośród nie więcej niż $l$ elementów, lecz dla stałego $l$ złożność dalej pozostaje $O(n)$ liniowa.
    \end{itemize}
    \item Znalezienie rozwiązania wektora $x$ z macierzy trójkątnej górnej:
    \begin{itemize}
        \item W każdym wierszu wykonujemy sumę nie więcej niż $3l$ elementów.
        \item Zatem złożoność obliczeniowa wynosi $O(n \cdot 3l) = O(n \cdot l)$, więc jeśli $l$ jest stałe, to złożoność obliczeniowa jest liniowa względem rozmiaru macierzy $n$.
    \end{itemize}
\end{enumerate}

\section*{Testy czasu działania}
Obliczoną złożoność czasową potwierdzają testy czasu działania programu.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{time.png}
    \caption{Porównanie czasu działania algorytmu eliminacji Gaussa dla macierzy A dla l=4 oraz l=10 w zależności od rozmiaru macierzy n.}
    \label{fig:times_plot}
\end{figure}

\subsection*{Obserwacje i wnioski}
Widzimy, że czas działania algorytmu rośnie liniowo wraz ze wzrostem rozmiaru macierzy $n$.
Dla większej wartości $l$ czas działania jest większy, co również zgadza się z wyliczoną złożonością czasową $O(n \cdot l^2)$.

\textbf{Wniosek:} Im gęstsza macierz (większe $l$), tym większa złożoność czasowa i pamięciowa, a co za tym idzie dłuższy czas działania algorytmu.

\newpage
\subsection*{Porównanie błędu obliczeń gdy wykonujemy eliminację Gaussa z i bez częściowego wyboru elementu głównego}
Gdy wykonujemy eliminację Gaussa bez częściowego wyboru elementu głównego, to możemy trafić na element przekątnej bliski zeru, co powoduje, że dzielimy przez bardzo małą liczbę i tracimy precyzję obliczeń. W efekcie błąd obliczeń rośnie wraz ze wzrostem rozmiaru macierzy $n$.
Aby temu zapobiec, stosujemy częściowy wybór elementu głównego, czyli w każdej kolumnie przed eliminacją szukamy największego elementu i zamieniamy wiersze tak, aby ten element znalazł się na przekątnej. W ten sposób unikamy dzielenia przez bardzo małe liczby i błąd obliczeń pozostaje niski nawet dla dużych rozmiarów macierzy $n$.

Na wykresie poniżej widzimy, że dla $n=16$ błąd jest bardzo podobny, natomiast dla większych $n$ błąd zaczyna rosnąć bardzo szybko.

Dla $n=10000$ błąd bez częściowego wyboru elementu głównego jest 1000 razy większy niż z częściowym wyborem elementu głównego. 
Dla jeszcze większych $n$ gdy nie robimy częściowego wyboru elementu głównego błąd rośnie aż do rzędu $10^{-10}$.
Dzięki wyborowi elementu głównego błąd możemy przybliżyć funkcją stałą równą około $3 \times 10^{-15}$.

\subsubsection*{Wniosek}
Przy obliczaniu rozwiązań układów równań metodą eliminacji Gaussa, warto stosować częściowy wybór elementu głównego, ponieważ pozwala to zachować dużo lepszą precyzję obliczeń, a co za tym idzie dużo bardziej precyzyjny wynik.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{errors.png}
    \caption{Porównanie błędu obliczeń dla algorytmu eliminacji Gaussa z i bez częściowego wyboru elementu głównego.}
    \label{fig:error_plot}
\end{figure}



\end{document}